#!/bin/bash
# 
# git-xflow -- An extension to git-flow, which automatize
# some usual tasks related to repository operations.
#
# Feel free to contribute to this project at:
#    https://github.com/golflima/git-xflow
# git-flow : http://github.com/nvie/gitflow
#
# Copyright 2016 Jérémy Walther (jeremy.walther@golflima.net).
#
# This file is part of git-xflow.
#
# git-xflow is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# git-xflow is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with git-xflow. If not, see <http://www.gnu.org/licenses/>



############## Constants ##############

# Colors
NC='\033[0m'
BLACK='\033[0;30m';         DARK_GRAY='\033[1;30m'
RED='\033[0;31m';           LIGHT_RED='\033[1;31m'
GREEN='\033[0;32m';         LIGHT_GREEN='\033[1;32m'
BROWN='\033[0;33m';         YELLOW='\033[1;33m'
BLUE='\033[0;34m';          LIGHT_BLUE='\033[1;34m'
PURPLE='\033[0;35m';        LIGHT_PURPLE='\033[1;35m'
CYAN='\033[0;36m';          LIGHT_CYAN='\033[1;36m'
LIGHT_GRAY='\033[0;37m';    WHITE='\033[1;37m'



############## General functions ##############

# Displays trace information message $@ in dark gray
trace() { echo -e "${DARK_GRAY}$@${NC}"; }

# Displays information message $@ in light blue
info() { echo -e "${LIGHT_BLUE}$@${NC}"; }

# Displays success message $@ in green
success() { echo -e "${GREEN}$@${NC}"; }

# Displays warning message $@ in brown/orange (overriden from gitflow-common)
warn() { echo -e "${BROWN}$@${NC}" >&2; }

# Ends the execution, and displays $@ in bold red (overriden from gitflow-common)
die() { warn "${LIGHT_RED}$@"; exit 1; }

# Ends the execution, and displays a last message ($@ if set, 'Done.' otherwise)
end() { [ -z "$@" ] && echo -e "${GREEN}Done.${NC}" || echo -e "${GREEN}$@${NC}"; exit 0; }

# Displays question message $@ in light purple
question() { echo -en "${LIGHT_PURPLE}$@${NC}"; }

# Ends the execution if given argument $1 is empty and displays usage of subcommand $2, or global usage if $2 is empty
require_argument() { [ -z "$(eval "echo \$$1")" ] && usage $2 && echo && die "Missing <$1> argument !"; }

# Ends the execution if given command $1 returns an error and displays debug information. Usage: 'assertok "command" $LINENO'
assertok() { ! $1 && warn "${LIGHT_RED}fatal: git-xflow v$GITXFLOW_VERSION, line $2, following command failed (err: $?):" && die "$1"; }

# Loads settings that can be overridden using git config
gitxflow_load_settings() {
    export REPOSITORY_NAME="$(basename $(git remote -v | grep fetch | cut -f2 | cut -d\  -f1) | cut -d. -f1)"
	export GITXFLOW_TEMPLATE_REVIEW="$(git config --get-all gitxflow.template.review)"
    export GITXFLOW_TEMPLATE_PATCH="$(git config --get-all gitxflow.template.patch)"
    export STAGING_BRANCH="$(git config --get gitflow.branch.staging)"
    export FEATURE_PREFIX="$(git config --get gitflow.prefix.feature)"
    export RELEASE_PREFIX="$(git config --get gitflow.prefix.release)"
    export HOTFIX_PREFIX="$(git config --get gitflow.prefix.hotfix)"
}

# Save default settings that can be overridden using git config
gitxflow_save_default_settings() {
    git config --remove-section gitxflow.branch
    assertok "git config --add gitxflow.branch.staging staging"
    git config --remove-section gitxflow.template
    assertok "git config --add gitxflow.template.review templates/revie/html"
    assertok "git config --add gitxflow.template.patch templates/patch/log"
    assertok "git config --add gitxflow.template.patch templates/patch/zip"
    assertok "git config --add gitxflow.template.patch templates/patch/sh"
    assertok "git config --add gitxflow.template.patch templates/patch/cmd"
    assertok "git config --add gitxflow.template.patch templates/patch/tar"
    assertok "git config --add gitxflow.template.patch templates/patch/targz"
}

# Parse and evaluate a given template. Usage: 'parse_template <template_name> <generated_file_name> <generated_file_suffix>'
parse_template() {
    [ -z "$1" ] && die "Missing template name."
    [ -z "$2" ] && die "Missing default generated file name."
    local template_name generated_file_name generated_file_suffix template_file lhs value rhs parsed_template
    template_name="$1"
    generated_file_name="$2"
    generated_file_suffix="$3"
    template_file="${GITXFLOW_DIR}/${template_name}"
    if [ -f "${template_name}" ] ; then
        template_file="${template_name}"
    elif [ -f "${DOT_GIT_DIR}/${template_name}" ] ; then
        template_file="${DOT_GIT_DIR}/${template_name}"
    elif [ -f "${DOT_GIT_DIR}/../${template_name}" ] ; then
        template_file="${DOT_GIT_DIR}/../${template_name}"
    fi
    if [ ! -f "${template_file}" ] ; then
        warn "Template '$1': file not found."
        return 1;
    fi
    parsed_template="$(<${template_file})"
    # Handle variable tags: '<%= variablename %>'
    while [[ "$parsed_template" =~ (<%=[[:blank:]]*([^%[:blank:]]*)[[:blank:]]*%>) ]] ; do
        lhs="${BASH_REMATCH[1]}"
        value="${BASH_REMATCH[2]}"
        rhs="$(eval echo -n "\"\$$value\"")"
        if [ $? != 0 ] ; then
            warn "Template '$1': error when evaluating variable tag: '$lhs'."
            return 10;
        fi
        parsed_template="${parsed_template//"$lhs"/"$rhs"}"
    done
    # Handle not echoed command tags: '<%@ command %>'
    while [[ "$parsed_template" =~ (<%@([^%]*)%>) ]] ; do
        lhs="${BASH_REMATCH[1]}"
        value="${BASH_REMATCH[2]}"
        eval "$value"
        if [ $? != 0 ] ; then
            warn "Template '$1': error when evaluating not echoed command tag: '$lhs'."
            return 11;
        fi
        parsed_template="${parsed_template//"$lhs"/}"
    done
    # Handle comment tags: '<%# comment #%>'
    while [[ "$parsed_template" =~ (<%#([^#]*)#%>) ]] ; do
        lhs="${BASH_REMATCH[1]}"
        parsed_template="${parsed_template//"$lhs"/}"
    done
    # Handle echoed command tags: '<%$ command %>'
    while [[ "$parsed_template" =~ (<%\$([^%]*)%>) ]] ; do
        lhs="${BASH_REMATCH[1]}"
        value="${BASH_REMATCH[2]}"
        rhs="$(eval "$value")"
        if [ $? != 0 ] ; then
            warn "Template '$1': error when evaluating echoed command tag: '$lhs'."
            return 12;
        fi
        parsed_template="${parsed_template//"$lhs"/"$rhs"}"
    done
    # Handle to-file command tags: '<%: command %>'
    while [[ "$parsed_template" =~ (<%:([^%]*)%>) ]] ; do
        lhs="${BASH_REMATCH[1]}"
        value="${BASH_REMATCH[2]}"
        eval "$value" > "${generated_file_name}${generated_file_suffix}"
        if [ $? = 0 ] ; then
            info "Template '$1': File '${generated_file_name}${generated_file_suffix}' generated."
            return 0;
        else
            warn "Template '$1': error when evaluating to-file command tag: '$lhs'."
            return 13;
        fi
    done
    if [ ! -z "${generated_file_name}${generated_file_suffix}" ] ; then
        echo -n "${parsed_template}" > "${generated_file_name}${generated_file_suffix}"
        info "Template '$1': File '${generated_file_name}${generated_file_suffix}' generated."
    else
        info "Template '$1': executed."
    fi
    return 0;
}